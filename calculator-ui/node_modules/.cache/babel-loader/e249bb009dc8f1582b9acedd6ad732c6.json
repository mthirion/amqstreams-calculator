{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});","map":{"version":3,"sources":["/development/workspace/internal/ui/myreact-kafka/node_modules/@babel/types/lib/definitions/core.js"],"names":["Object","defineProperty","exports","value","patternLikeCommon","functionTypeAnnotationCommon","functionDeclarationCommon","functionCommon","classMethodOrPropertyCommon","classMethodOrDeclareMethodCommon","_is","require","_isValidIdentifier","_helperValidatorIdentifier","_constants","_utils","defineType","defineAliasedType","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","default","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","key","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","body","label","optional","assign","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","params","generator","async","returnType","declare","id","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","implements","mixins","abstract","source","exportKind","validateOptional","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","await","importKind","accessibility","static","override","access","tag","quasi","assertShape","raw","cooked","tail","quasis","delegate","assertOptionalChainStart","readonly","variance"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon, {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});"]},"metadata":{},"sourceType":"script"}